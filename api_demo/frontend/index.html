<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROS Web Visualizer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: #fff; font-family: Arial, sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
        #container { width: 100vw; height: 100vh; }
        .status-item { margin-bottom: 5px; }
        .status-label { font-weight: bold; color: #aaa; }
        .status-value { color: #fff; }
    </style>
    <!-- Import maps polyfill -->
    <script async src="/static/js/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "/static/js/three.module.js",
                "three/addons/": "/static/js/"
            }
        }
    </script>
    <script src="/static/js/socket.io.min.js"></script>
</head>
<body>
    <div id="info">
        <h3>ROS Visualizer</h3>
        <div class="status-item">
            <span class="status-label">Status:</span>
            <span id="connection-status" class="status-value" style="color: #f00">Disconnected</span>
        </div>
        <div class="status-item">
            <span class="status-label">Localization:</span>
            <span id="loc-pos" class="status-value">N/A</span>
        </div>
        <div class="status-item">
            <span class="status-label">Global Points:</span>
            <span id="global-points-count" class="status-value">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">Current Scan:</span>
            <span id="cur-scan-count" class="status-value">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">Path Points:</span>
            <span id="path-count" class="status-value">0</span>
        </div>
    </div>
    <div id="container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        // Grid helper
        const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x222222);
        scene.add(gridHelper);
        
        // Axes helper
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(10, 10, 10);
        camera.lookAt(0, 0, 0);

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Objects storage
        let globalPointsCloud = null;
        let curScanCloud = null;
        let robotMesh = null;
        let pathLine = null;
        const DISABLE_LIDAR_SCAN = true;

        // Socket.io connection
        // Connect to the same host that served the page
        console.log('Attempting to connect to:', window.location.origin);
        const socket = io(window.location.origin, {
            transports: ['websocket', 'polling'] // Force explicit transports to avoid potential DNS issues with some auto-discovery
        });
        const statusEl = document.getElementById('connection-status');

        socket.on('connect_error', (err) => {
            console.error('Connection Error:', err);
            statusEl.textContent = 'Error: ' + err.message;
            statusEl.style.color = '#f00';
        });

        socket.on('connect', () => {
            statusEl.textContent = 'Connected';
            statusEl.style.color = '#0f0';
            console.log('Connected to server');
        });

        socket.on('disconnect', () => {
            statusEl.textContent = 'Disconnected';
            statusEl.style.color = '#f00';
            console.log('Disconnected from server');
        });

        socket.on('global_points', (data) => {
            if (globalPointsCloud) scene.remove(globalPointsCloud);
            const float32View = new Float32Array(data);
            const numPoints = float32View.length / 3;
            document.getElementById('global-points-count').textContent = numPoints;
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(float32View, 3));
            const material = new THREE.PointsMaterial({ 
                color: 0x888888, 
                size: 0.05,
                sizeAttenuation: true 
            });
            globalPointsCloud = new THREE.Points(geometry, material);
            globalPointsCloud.rotation.x = -Math.PI / 2;
            scene.add(globalPointsCloud);
        });

        // Handle Localization (Robot Position)
        socket.on('localization', (data) => {
            const pos = data.position;
            const ori = data.orientation;
            
            document.getElementById('loc-pos').textContent = `(${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`;
            
            if (!robotMesh) {
                const geometry = new THREE.BoxGeometry(0.5, 0.2, 0.3);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                robotMesh = new THREE.Mesh(geometry, material);
                // Add direction arrow
                const arrowHelper = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), 1, 0xffff00);
                robotMesh.add(arrowHelper);
                scene.add(robotMesh);
            }
            
            // Update position (ROS Z-up to Three Y-up)
            robotMesh.position.set(pos.x, pos.z, -pos.y);
            
            // Update orientation
            const quaternion = new THREE.Quaternion(ori.x, ori.z, -ori.y, ori.w);
            // This quaternion mapping might need adjustment based on exact coordinate frames
            // For now, just position is key
            // A simpler way is to construct rotation from quaternion directly if frames align
            
            // Let's try to just set quaternion directly but swapping axes
            // ROS (x, y, z, w) -> Three (x, z, -y, w) roughly
            robotMesh.setRotationFromQuaternion(new THREE.Quaternion(ori.x, ori.z, -ori.y, ori.w));
            
            // Make camera follow robot if needed (optional)
            // camera.position.set(pos.x - 5, pos.z + 5, -pos.y);
            // camera.lookAt(pos.x, pos.z, -pos.y);
        });

        socket.on('cur_scan', (data) => {
            if (curScanCloud) {
                scene.remove(curScanCloud);
                curScanCloud = null;
            }
            const float32View = new Float32Array(data);
            const numPoints = float32View.length / 3;
            document.getElementById('cur-scan-count').textContent = numPoints;
            if (DISABLE_LIDAR_SCAN) return;
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(float32View, 3));
            const material = new THREE.PointsMaterial({ 
                color: 0xff0000, 
                size: 0.08,
                sizeAttenuation: true 
            });
            curScanCloud = new THREE.Points(geometry, material);
            curScanCloud.rotation.x = -Math.PI / 2;
            scene.add(curScanCloud);
        });

        // Handle Path
        socket.on('path', (data) => {
            if (pathLine) scene.remove(pathLine);
            
            const pathPoints = data.path;
            document.getElementById('path-count').textContent = pathPoints.length;
            
            const points = [];
            pathPoints.forEach(p => {
                points.push(new THREE.Vector3(p.x, p.z, -p.y));
            });
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2 });
            
            pathLine = new THREE.Line(geometry, material);
            scene.add(pathLine);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
