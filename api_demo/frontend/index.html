<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROS Web Visualizer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: #fff; font-family: Arial, sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            pointer-events: auto;
        }
        #container { width: 100vw; height: 100vh; }
        .status-item { margin-bottom: 5px; }
        .status-label { font-weight: bold; color: #aaa; }
        .status-value { color: #fff; }
    </style>
    <!-- Import maps polyfill -->
    <script async src="/static/js/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "/static/js/three.module.js",
                "three/addons/": "/static/js/"
            }
        }
    </script>
    <script src="/static/js/socket.io.min.js"></script>
</head>
<body>
    <div id="info">
        <h3>ROS Visualizer</h3>
        <div class="status-item">
            <span class="status-label">Status:</span>
            <span id="connection-status" class="status-value" style="color: #f00">Disconnected</span>
        </div>
        <div class="status-item">
            <label>
                <input type="checkbox" id="toggle-loc" checked> 
                <span class="status-label">Localization:</span>
            </label>
            <span id="loc-pos" class="status-value">N/A</span>
        </div>
        <div class="status-item">
            <label>
                <input type="checkbox" id="toggle-global" checked>
                <span class="status-label">Global Points:</span>
            </label>
            <span id="global-points-count" class="status-value">0</span>
        </div>
        <div class="status-item">
            <label>
                <input type="checkbox" id="toggle-scan" checked>
                <span class="status-label">Current Scan:</span>
            </label>
            <span id="cur-scan-count" class="status-value">0</span>
        </div>
        <div class="status-item">
            <label>
                <input type="checkbox" id="toggle-registered" checked>
                <span class="status-label">Registered Cloud:</span>
            </label>
            <span id="cloud-registered-count" class="status-value">0</span>
        </div>
        <div class="status-item">
            <label>
                <input type="checkbox" id="toggle-path" checked>
                <span class="status-label">Path Points:</span>
            </label>
            <span id="path-count" class="status-value">0</span>
        </div>
    </div>
    <div id="container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        // Grid helper
        const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x222222);
        scene.add(gridHelper);
        
        // Axes helper
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(10, 10, 10);
        camera.lookAt(0, 0, 0);

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Objects storage
        let globalPointsCloud = null;
        let curScanCloud = null;
        let cloudRegisteredCloud = null;
        let robotMesh = null;
        let pathLine = null;
        const DISABLE_LIDAR_SCAN = true; // This seems to be a hardcoded flag, maybe we can use the checkbox instead

        // Toggles
        const toggleLoc = document.getElementById('toggle-loc');
        const toggleGlobal = document.getElementById('toggle-global');
        const toggleScan = document.getElementById('toggle-scan');
        const toggleRegistered = document.getElementById('toggle-registered');
        const togglePath = document.getElementById('toggle-path');

        toggleLoc.addEventListener('change', (e) => {
            if (robotMesh) robotMesh.visible = e.target.checked;
        });
        toggleGlobal.addEventListener('change', (e) => {
            if (globalPointsCloud) globalPointsCloud.visible = e.target.checked;
        });
        toggleScan.addEventListener('change', (e) => {
            if (curScanCloud) curScanCloud.visible = e.target.checked;
        });
        toggleRegistered.addEventListener('change', (e) => {
            if (cloudRegisteredCloud) cloudRegisteredCloud.visible = e.target.checked;
        });
        togglePath.addEventListener('change', (e) => {
            if (pathLine) pathLine.visible = e.target.checked;
        });

        function toFloat32(payload) {
            if (payload && payload.points && Array.isArray(payload.points)) {
                const n = payload.points.length;
                const arr = new Float32Array(n * 3);
                for (let i = 0; i < n; i++) {
                    const p = payload.points[i];
                    arr[i * 3] = p.x;
                    arr[i * 3 + 1] = p.y;
                    arr[i * 3 + 2] = p.z;
                }
                return arr;
            }
            if (payload instanceof ArrayBuffer) {
                return new Float32Array(payload);
            }
            if (payload && payload.buffer && payload.byteLength !== undefined) {
                return new Float32Array(payload.buffer, payload.byteOffset || 0, Math.floor(payload.byteLength / 4));
            }
            if (typeof payload === 'string') {
                try {
                    const bstr = atob(payload);
                    const buf = new ArrayBuffer(bstr.length);
                    const view = new Uint8Array(buf);
                    for (let i = 0; i < bstr.length; i++) view[i] = bstr.charCodeAt(i);
                    return new Float32Array(buf);
                } catch (e) {
                    return null;
                }
            }
            if (Array.isArray(payload) && typeof payload[0] === 'number') {
                return new Float32Array(payload);
            }
            return null;
        }

        async function toFloat32Async(payload) {
            if (payload instanceof Blob) {
                const buf = await payload.arrayBuffer();
                return new Float32Array(buf);
            }
            return toFloat32(payload);
        }

        function fitView(positions) {
            if (!positions || positions.length < 3) return;
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.computeBoundingSphere();
            const c = geometry.boundingSphere.center;
            const r = geometry.boundingSphere.radius;
            controls.target.set(c.x, c.y, c.z);
            const k = 2.5;
            camera.position.set(c.x + r * k, c.y + r * k, c.z + r * k);
        }

        const VOXEL_SIZE = 0.1;
        let cloudRegisteredVoxelMap = new Map();
        function accumulateVoxel(positions) {
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                const z = positions[i + 2];
                const vx = Math.floor(x / VOXEL_SIZE);
                const vy = Math.floor(y / VOXEL_SIZE);
                const vz = Math.floor(z / VOXEL_SIZE);
                const key = vx + ',' + vy + ',' + vz;
                if (!cloudRegisteredVoxelMap.has(key)) cloudRegisteredVoxelMap.set(key, [x, y, z]);
            }
            const out = new Float32Array(cloudRegisteredVoxelMap.size * 3);
            let idx = 0;
            for (const p of cloudRegisteredVoxelMap.values()) {
                out[idx++] = p[0];
                out[idx++] = p[1];
                out[idx++] = p[2];
            }
            return out;
        }

        // Socket.io connection
        // Connect to the same host that served the page
        console.log('Attempting to connect to:', window.location.origin);
        const socket = io(window.location.origin, {
            transports: ['websocket', 'polling'] // Force explicit transports to avoid potential DNS issues with some auto-discovery
        });
        const statusEl = document.getElementById('connection-status');

        socket.on('connect_error', (err) => {
            console.error('Connection Error:', err);
            statusEl.textContent = 'Error: ' + err.message;
            statusEl.style.color = '#f00';
        });

        socket.on('connect', () => {
            statusEl.textContent = 'Connected';
            statusEl.style.color = '#0f0';
            console.log('Connected to server');
        });

        socket.on('disconnect', () => {
            statusEl.textContent = 'Disconnected';
            statusEl.style.color = '#f00';
            console.log('Disconnected from server');
        });

        socket.on('global_points', async (data) => {
            if (globalPointsCloud) scene.remove(globalPointsCloud);
            const positions = await toFloat32Async(data);
            if (!positions) return;
            const numPoints = positions.length / 3;
            document.getElementById('global-points-count').textContent = numPoints;
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: 0x888888, size: 0.05, sizeAttenuation: true });
            globalPointsCloud = new THREE.Points(geometry, material);
            globalPointsCloud.rotation.x = -Math.PI / 2;
            globalPointsCloud.visible = toggleGlobal.checked;
            scene.add(globalPointsCloud);
            if (toggleGlobal.checked) fitView(positions);
        });

        // Handle Localization (Robot Position)
        socket.on('localization', (data) => {
            const pos = data.position;
            const ori = data.orientation;
            
            document.getElementById('loc-pos').textContent = `(${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`;
            
            if (!robotMesh) {
                const geometry = new THREE.BoxGeometry(0.5, 0.2, 0.3);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                robotMesh = new THREE.Mesh(geometry, material);
                // Add direction arrow
                const arrowHelper = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), 1, 0xffff00);
                robotMesh.add(arrowHelper);
                robotMesh.visible = toggleLoc.checked;
                scene.add(robotMesh);
            }
            
            // Update position (ROS Z-up to Three Y-up)
            robotMesh.position.set(pos.x, pos.z, -pos.y);
            
            // Update orientation
            const quaternion = new THREE.Quaternion(ori.x, ori.z, -ori.y, ori.w);
            // This quaternion mapping might need adjustment based on exact coordinate frames
            // For now, just position is key
            // A simpler way is to construct rotation from quaternion directly if frames align
            
            // Let's try to just set quaternion directly but swapping axes
            // ROS (x, y, z, w) -> Three (x, z, -y, w) roughly
            robotMesh.setRotationFromQuaternion(new THREE.Quaternion(ori.x, ori.z, -ori.y, ori.w));
            
            // Make camera follow robot if needed (optional)
            // camera.position.set(pos.x - 5, pos.z + 5, -pos.y);
            // camera.lookAt(pos.x, pos.z, -pos.y);
        });

        socket.on('cur_scan', async (data) => {
            if (curScanCloud) {
                scene.remove(curScanCloud);
                curScanCloud = null;
            }
            if (!toggleScan.checked) return;
            const positions = await toFloat32Async(data);
            if (!positions) return;
            const numPoints = positions.length / 3;
            document.getElementById('cur-scan-count').textContent = numPoints;
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: 0xff0000, size: 0.08, sizeAttenuation: true });
            curScanCloud = new THREE.Points(geometry, material);
            curScanCloud.rotation.x = -Math.PI / 2;
            curScanCloud.visible = toggleScan.checked;
            scene.add(curScanCloud);
            fitView(positions);
        });

        socket.on('cloud_registered', async (data) => {
            const incoming = await toFloat32Async(data);
            if (!incoming) return;
            const aggregated = accumulateVoxel(incoming);
            const numPoints = aggregated.length / 3;
            document.getElementById('cloud-registered-count').textContent = numPoints;
            if (!cloudRegisteredCloud) {
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(aggregated, 3));
                const material = new THREE.PointsMaterial({ color: 0x00ff00, size: 0.05, sizeAttenuation: true });
                cloudRegisteredCloud = new THREE.Points(geometry, material);
                cloudRegisteredCloud.rotation.x = -Math.PI / 2;
                cloudRegisteredCloud.visible = toggleRegistered.checked;
                scene.add(cloudRegisteredCloud);
            } else {
                cloudRegisteredCloud.geometry.setAttribute('position', new THREE.BufferAttribute(aggregated, 3));
                cloudRegisteredCloud.geometry.attributes.position.needsUpdate = true;
                cloudRegisteredCloud.visible = toggleRegistered.checked;
            }
            if (toggleRegistered.checked) fitView(aggregated);
        });

        // Handle Path
        socket.on('path', (data) => {
            if (pathLine) scene.remove(pathLine);
            
            const pathPoints = data.path;
            document.getElementById('path-count').textContent = pathPoints.length;
            
            const points = [];
            pathPoints.forEach(p => {
                points.push(new THREE.Vector3(p.x, p.z, -p.y));
            });
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2 });
            
            pathLine = new THREE.Line(geometry, material);
            pathLine.visible = togglePath.checked;
            scene.add(pathLine);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
